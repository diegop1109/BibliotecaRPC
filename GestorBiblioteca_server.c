/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "GestorBiblioteca.h"
#define MAX_FILENAME_LENGTH 100

TLibro *Biblioteca = NULL; // Vector dinámico de libros
int NumLibros = 0;		   // Número de libros almacenados en el vector dinámico.
int Tama = 0;			   // Tamaño del vector dinámico. El incremento será por bloques de 4 libros.
int IdAdmin = -1;		   // Copia del Identificador de Administración enviado al usuario.
Cadena NomFichero = "";	   // Copia del nombre del último fichero binario que se ha cargado en memoria.
int CampoOrdenacion = 0;   // Copia del último campo de ordenación realizado

int *conexion_1_svc(int *argp, struct svc_req *rqstp)
{
	static int result;

	if (*argp != 1234)
	{
		result = -2;
	}
	else if (IdAdmin != -1)	//no hay sesiones de administrador iniciadas en este momento
	{ 
		result = -1;
	}
	else
	{
		IdAdmin = 1 + rand() % RAND_MAX;
		result = IdAdmin;
	}
	return &result;
}

bool_t *
desconexion_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;
	if (*argp != IdAdmin)
	{
		result = FALSE;
	} else
	{
		result = TRUE;
		IdAdmin = -1;	//resetear la variable ahora que no hay ningun admin conectado
	}
	
	return &result;
}

int *cargardatos_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	printf("se estan cargando los datos de biblioteca\n");
	static int result = 1;
	strcpy(NomFichero, argp->Datos); //(*argp).Datos
	FILE *fDatos = NULL;

	if (argp->Ida != IdAdmin)
	{
		result = -1;
	} else 
	{
		fDatos = fopen("Biblioteca.cdat", "rb");
		if (fDatos ==NULL)
		{
			result = 0;
		} else 
		{
			fread(&NumLibros,sizeof(NumLibros),1,fDatos);
			TLibro repo[NumLibros];
			
			Biblioteca = (TLibro *)malloc(sizeof(TLibro) * NumLibros);
			printf("cuantos libros hay: %d\n",NumLibros);
			if (Biblioteca == NULL)
			{
				printf("No hay libros para leer en el fichero\n");
			} else 
			{
				printf("se han cargado los datos de biblioteca\n");
				fread(Biblioteca, sizeof(TLibro) * NumLibros, NumLibros, fDatos);
				for (size_t i = 0; i < NumLibros; i++)
				{
					
					repo[i] = Biblioteca[i];
					printf("imprimir> \n");
					printf("%d %s %s ",repo[i].Anio,repo[i].Autor,repo[i].Idioma);
					printf("%s %d %d %s %s\n",repo[i].Isbn,repo[i].NoLibros,repo[i].NoPrestados,repo[i].Pais,repo[i].Titulo);
					/* code */
				}
				
			}
			fclose(fDatos);
			
		}
		
	}
	

	return &result;
}

bool_t *
guardardatos_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *nuevolibro_1_svc(TNuevo *argp, struct svc_req *rqstp)
{
	static int result;
	printf("datos del nuevo libro-> Isbn:%s Autor:%s Titulo:%s Anho:%d Pais:%s Idioma:%s\n",
							   *argp->Libro.Isbn, *argp->Libro.Autor, *argp->Libro.Titulo,
							   (int *)argp->Libro.Anio, *argp->Libro.Pais, *argp->Libro.Idioma);

	
	return &result;
}

int *comprar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *retirar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

bool_t *
ordenar_1_svc(TOrdenacion *argp, struct svc_req *rqstp)
{
	static bool_t result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *nlibros_1_svc(int *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *buscar_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

TLibro *
descargar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static TLibro result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *prestar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *devolver_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}
