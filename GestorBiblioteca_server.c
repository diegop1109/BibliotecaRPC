/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "GestorBiblioteca.h"
#define MAX_FILENAME_LENGTH 100

TLibro *Biblioteca = NULL; // Vector dinámico de libros
int NumLibros = 0;		   // Número de libros almacenados en el vector dinámico.
int Tama = 0;			   // Tamaño del vector dinámico. El incremento será por bloques de 4 libros.
int IdAdmin = -1;		   // Copia del Identificador de Administración enviado al usuario.
Cadena NomFichero = "";	   // Copia del nombre del último fichero binario que se ha cargado en memoria.
int CampoOrdenacion = 0;   // Copia del último campo de ordenación realizado


/************************************************
*	CONECTAR A ADMIN
************************************************/
int *conexion_1_svc(int *argp, struct svc_req *rqstp)
{
	static int result;

	if (*argp != 1234)
	{
		result = -2;
	}
	else if (IdAdmin != -1) // no hay sesiones de administrador iniciadas en este momento
	{
		result = -1;
	}
	else
	{
		IdAdmin = 1 + rand() % RAND_MAX;
		result = IdAdmin;
	}
	return &result;
}

/***********************************************
*	DESCONECTAR DE ADMIN
************************************************/
bool_t *
desconexion_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;
	if (*argp != IdAdmin)
	{
		result = FALSE;
	}
	else
	{
		result = TRUE;
		IdAdmin = -1; // resetear la variable ahora que no hay ningun admin conectado
	}

	return &result;
}

/*********************************************
*	CARGAR LA BIBLIOTECA EN MEMORIA
**********************************************/
int *cargardatos_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	printf("se estan cargando los datos de biblioteca\n");
	static int result = 1;
	strcpy(NomFichero, argp->Datos); //(*argp).Datos
	FILE *fDatos = NULL;

	if (argp->Ida != IdAdmin)
	{
		result = -1;
	}
	else
	{
		fDatos = fopen("Biblioteca.cdat", "rb");
		if (fDatos == NULL)
		{
			result = 0;
		}
		else
		{
			fread(&NumLibros, sizeof(NumLibros), 1, fDatos);
			//TLibro repo;//[NumLibros];

			Biblioteca = (TLibro *)malloc(sizeof(TLibro) * NumLibros);
			printf("cuantos libros hay: %d\n", NumLibros);
			if (Biblioteca == NULL)
			{
				printf("No hay libros para leer en el fichero\n");
			}
			else
			{
				printf("se han cargado los datos de biblioteca\n");
				fread(Biblioteca, sizeof(TLibro) * NumLibros, NumLibros, fDatos);
				#define repo Biblioteca[i]
				for (size_t i = 0; i < NumLibros; i++)
				{

					printf("imprimir> %ld\n", i);
					printf("%d %s %s ", repo.Anio, repo.Autor, repo.Idioma);
					printf("%s %d %d %s %s\n", repo.Isbn, repo.NoLibros, repo.NoPrestados, repo.Pais, repo.Titulo);
				}
			    #undef repo	
			}
			fclose(fDatos);
		}
	}

	return &result;
}

/***************************************
*	GUARDAR BIBLIOTECA EN FICHERO
*****************************************/
bool_t *
guardardatos_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;

	FILE *nuevoFichero = NULL;
	if (*argp != IdAdmin)
	{
		result = FALSE;
	}
	else
	{
		nuevoFichero = fopen(NomFichero, "wb");
		if (nuevoFichero == NULL)
		{
			result = FALSE;
		}else
		{
			if (Biblioteca == NULL || NumLibros <= 0)
			{
				result = FALSE;
			}
			else
			{
				result = TRUE;
				fwrite(&NumLibros, sizeof(NumLibros), 1, nuevoFichero);					 
				fwrite(Biblioteca, sizeof(TLibro) * NumLibros, NumLibros, nuevoFichero); 
			}
			fclose(nuevoFichero);
		}
		
	}

	return &result;
}

/*****************************************
*	SUBIR NUEVO LIBRO A LA BIBLIOTECA
******************************************/
int *nuevolibro_1_svc(TNuevo *argp, struct svc_req *rqstp)
{
	static int result;

	if (argp->Ida != IdAdmin)
	{
		result = -1;
	}
	else
	{
		result = 0;
		printf("datos del nuevo libro-> Isbn:%s Autor:%s Titulo:%s Anho:%d Pais:%s Idioma:%s\n",
			   argp->Libro.Isbn, argp->Libro.Autor, argp->Libro.Titulo,
			   argp->Libro.Anio, argp->Libro.Pais, argp->Libro.Idioma);
		NumLibros = NumLibros + 1;
		Biblioteca = (TLibro *)realloc(Biblioteca, sizeof(TLibro) * NumLibros);
		Biblioteca[NumLibros-1] = argp->Libro; //error
		int i = NumLibros-1;
		printf("imprimir> %d\n", i);
		printf("%d %s %s ", Biblioteca[i].Anio, Biblioteca[i].Autor, Biblioteca[i].Idioma);
		printf("%s %d %d %s %s\n", Biblioteca[i].Isbn, Biblioteca[i].NoLibros, Biblioteca[i].NoPrestados, Biblioteca[i].Pais, Biblioteca[i].Titulo);
	}

	return &result;
}

/****************************************************************
*	COMPRAR MAS COPIAS (DIS) DE UNA LIBRO EN LA BIBLIOTECA
*****************************************************************/
int *comprar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;

	if (argp->Ida != IdAdmin)
	{
		result = -1;
	}else
	{
		result = 0;
		for (size_t i = 0; i < NumLibros; i++)
		{
			if (strstr(Biblioteca[i].Isbn, argp->Isbn))
			{
				Biblioteca[i].NoLibros = Biblioteca[i].NoLibros + argp->NoLibros;
				result = 1;
				break;
			}
			
		}
		
	}
	

	return &result;
}


/****************************************************************
*	RETIRAR N COPIAS (DIS) DE UN LIBRO EN LA BIBLIOTECA
*****************************************************************/
int *retirar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;

	
	if (argp->Ida != IdAdmin)
	{
		result = -1;
	}else
	{
		result = 0;
		for (size_t i = 0; i < NumLibros; i++)
		{
			if (strstr(Biblioteca[i].Isbn, argp->Isbn))
			{
				if (Biblioteca[i].NoLibros - argp->NoLibros >= 0)
				{
					Biblioteca[i].NoLibros = Biblioteca[i].NoLibros - argp->NoLibros;
				} else 
				{
					Biblioteca[i].NoLibros = 0;
				}
				
				result = 1;
				break;
			}
			
		}
		
	}

	return &result;
}


/****************************************************************
*	ORDENAR LIBROS EN LA BIBLIOTECA EN BASE A UN CRITERIO
*****************************************************************/
//usamos la implementacion de strcmp mediante la definicion del metodo compare
int compareBooks(const void* a, const void* b) 
{ 
    switch (CampoOrdenacion)
	{
	case 0: //ordenar por ISBN
		return strcmp(((struct TLibro *)a)->Isbn,((struct TLibro *)b)->Isbn);
		break;
	case 1: //ordenar por titulo
		return strcmp(((struct TLibro *)a)->Titulo,((struct TLibro *)b)->Titulo);
		break;
	case 2: //ordenar por autor
		return strcmp(((struct TLibro *)a)->Autor,((struct TLibro *)b)->Autor);
		break; 
	case 3: //ordenar por anio
		return ((struct TLibro *)a)->Anio - ((struct TLibro *)b)->Anio;
		break;
	case 4: //ordenar por pais
		return strcmp(((struct TLibro *)a)->Pais,((struct TLibro *)b)->Pais);
		break;
	case 5: //ordenar por idioma
		return strcmp(((struct TLibro *)a)->Idioma,((struct TLibro *)b)->Idioma);
		break;
	case 6: // ordenar por numero de libros disponibles
		return ((struct TLibro *)a)->NoLibros - ((struct TLibro *)b)->NoLibros;
		break;
	case 7: //ordenar por numero de libros prestados
		return ((struct TLibro *)a)->NoPrestados - ((struct TLibro *)b)->NoPrestados;
		break;
	case 8: //ordenar por numero de libros en espera
		return ((struct TLibro *)a)->NoListaEspera - ((struct TLibro *)b)->NoListaEspera;
		break;
	}
} 
bool_t *
ordenar_1_svc(TOrdenacion *argp, struct svc_req *rqstp)
{
	static bool_t result;

	if (argp->Ida != IdAdmin)
	{
		result = FALSE;
	} else
	{
		result = TRUE;
		CampoOrdenacion = argp->Campo;
		//qsort se encarga de ordenar el vector
		qsort(Biblioteca, NumLibros, sizeof(struct TLibro), compareBooks);
		
	}

	return &result;
}



/****************************************************************
*	DEVUELVE NUMERO DE LIBROS EN LA BIBLIOTECA
*****************************************************************/
int *nlibros_1_svc(int *argp, struct svc_req *rqstp)
{
	static int result;

	if (*argp != IdAdmin && *argp != 3)
	{
		result = -1;
	} else 
	{
		result = NumLibros;
	}
	

	return &result;
}


/***************************************************************************
*	SE HACE UNA BUSQUEDA MEDIANTE UN STRING PARA DEVOLVER UNA POSICION
***************************************************************************/
int *buscar_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	static int result;
	if (argp->Ida != IdAdmin && argp->Ida != 3)
	{
		result = -1;
	} else 
	{
		result = -2;
		for (size_t i = 0; i < NumLibros; i++)
		{
			if (strcmp(Biblioteca[i].Isbn, argp->Datos) == 0)
			{
				result = i;
			}
		}
	}

	return &result;
}


/****************************************************************
*	MUESTRA EL LISTADO DE LIBROS DE LA BIBLIOTECA
*****************************************************************/
TLibro *
descargar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static TLibro result;

	if (argp->Ida != IdAdmin && argp->Ida != 3)
	{
		return NULL;
	} else 
	{
		result = Biblioteca[argp->Pos];	
	}
	

	return &result;
}


/****************************************************************
*	OPCION DE USUARIO PARA PEDIR LIBRO PRESTADO
*****************************************************************/
int *prestar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *devolver_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}
